# Code Standards - Notion Assistant

This document describes the code standards and conventions adopted in the Notion Assistant project to ensure quality, consistency, and maintainability of the code.

## Overview

We follow a consistent set of standards to facilitate collaboration and maintain code quality. These standards are inspired by Python community best practices and the style guides of well-established projects.

## Code Style

### PEP 8

We adhere to [PEP 8](https://www.python.org/dev/peps/pep-0008/) as the foundation for Python code style:

- **Indentation**: 4 spaces (no tabs)
- **Line length**: Maximum of 88 characters
- **Line breaks**: Break before binary operators
- **Blank lines**: 2 lines before class definitions and top-level functions
- **Imports**: Grouped by standard and ordered alphabetically

```python
# Correct imports
import os
import sys
from typing import Dict, List, Optional

import pandas as pd
import requests

from app.core import security
from app.db import database
```

### Formatting with Black

We use [Black](https://black.readthedocs.io/) as an automatic code formatter:

```bash
# Format a file
black app/main.py

# Format all files
black app/
```

### Docstrings

We use Google-style docstrings for code documentation:

```python
def generate_content(prompt: str, provider: str = "openai") -> str:
    """Generates content using the specified AI provider.

    Args:
        prompt: The prompt or instruction to generate content.
        provider: The AI provider to use (default: "openai").

    Returns:
        The content generated by the AI model.

    Raises:
        ValueError: If the provider is not supported.
        APIError: If there is an error in the API call.
    """
    # Implementation
```

## Naming Conventions

### Variables and Functions

- **snake_case** for variables, functions, and methods
- **Descriptive names** that are meaningful
- **Underscore prefix** for private variables and methods

```python
# Good
user_profile = get_user_profile(user_id)
total_items = calculate_total_items(cart)
_internal_cache = {}

# Bad
u = get_u(uid)
t = calc(c)
internalCache = {}
```

### Classes

- **PascalCase** (or CapWords) for class names
- **Specific names** that clearly describe the entity

```python
# Good
class UserRepository:
    pass

class ContentGenerator:
    pass

class NotionIntegration:
    pass

# Bad
class Data:
    pass

class Manager:
    pass
```

### Constants

- **UPPERCASE_WITH_UNDERSCORES** for constants
- Defined at the module level

```python
# Good
MAX_RETRIES = 3
DEFAULT_TIMEOUT = 30
API_BASE_URL = "https://api.example.com/v1"

# Bad
maxRetries = 3
default_timeout = 30
```

### Modules and Packages

- **snake_case** for module and package names
- Short and descriptive names

```
app/
├── core/
│   ├── config.py
│   ├── security.py
│   └── exceptions.py
├── api/
│   ├── endpoints/
│   ├── dependencies.py
│   └── router.py
└── services/
    ├── content_service.py
    ├── notion_service.py
    └── ai_service.py
```

## Programming Standards

### Static Typing

We use Python type hints to improve readability and enable static checking:

```python
from typing import Dict, List, Optional, Union

def get_user_by_id(user_id: str) -> Optional[Dict[str, any]]:
    """Fetches a user by ID."""
    # Implementation

def process_items(items: List[Dict[str, Union[str, int]]]) -> List[str]:
    """Processes a list of items."""
    # Implementation
```

### Asynchronous Programming

We use asynchronous programming with `async/await` for I/O-bound operations:

```python
async def fetch_content(prompt: str) -> str:
    """Fetches content from an external API asynchronously."""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://api.example.com/generate",
            json={"prompt": prompt}
        )
        response.raise_for_status()
        data = response.json()
        return data["content"]
```

### Exception Handling

We prefer specific exception handling:

```python
try:
    result = await api_client.fetch_data(user_id)
except ApiConnectionError as e:
    logger.error(f"Connection error: {str(e)}")
    raise ServiceUnavailableError("Service temporarily unavailable")
except ApiTimeoutError as e:
    logger.warning(f"Timeout error: {str(e)}")
    raise RequestTimeoutError("Request timed out")
except ApiError as e:
    logger.error(f"API error: {str(e)}")
    raise InternalServerError("Internal server error")
```

### Repository Pattern

We use the repository pattern for data access:

```python
class UserRepository:
    def __init__(self, db: Database):
        self.db = db

    async def get_by_id(self, user_id: str) -> Optional[User]:
        """Fetches a user by ID."""
        query = users.select().where(users.c.id == user_id)
        user_data = await self.db.fetch_one(query)
        if user_data:
            return User(**user_data)
        return None

    async def create(self, user: UserCreate) -> str:
        """Creates a new user."""
        user_id = str(uuid.uuid4())
        query = users.insert().values(
            id=user_id,
            username=user.username,
            email=user.email,
            password_hash=get_password_hash(user.password)
        )
        await self.db.execute(query)
        return user_id
```

### Dependency Injection

We use dependency injection to facilitate testing and maintenance:

```python
# app/api/dependencies.py
from fastapi import Depends, HTTPException
from app.db.database import get_database
from app.repositories.user_repository import UserRepository

async def get_user_repository(db = Depends(get_database)):
    return UserRepository(db)

# app/api/endpoints/users.py
from fastapi import APIRouter, Depends
from app.api.dependencies import get_user_repository
from app.repositories.user_repository import UserRepository

router = APIRouter()

@router.get("/users/{user_id}")
async def get_user(
    user_id: str,
    user_repo: UserRepository = Depends(get_user_repository)
):
    user = await user_repo.get_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

## Testing

### Test Structure

We organize tests hierarchically:

```
tests/
├── unit/                # Unit tests
│   ├── test_services.py
│   ├── test_repositories.py
│   └── test_utils.py
├── integration/         # Integration tests
│   ├── test_api.py
│   └── test_database.py
└── conftest.py          # Shared fixtures
```

### Test Fixtures

We use pytest fixtures to prepare the test environment:

```python
# tests/conftest.py
import pytest
import asyncio
from databases import Database
from app.core.config import settings
from app.db.database import metadata

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def test_db():
    # Use test database
    test_db_url = settings.database_url.replace(
        "notionassistant", "notionassistant_test"
    )
    db = Database(test_db_url)
    await db.connect()

    # Create tables
    engine = create_engine(test_db_url)
    metadata.create_all(engine)

    yield db

    # Clean up after tests
    await db.disconnect()
    metadata.drop_all(engine)

@pytest.fixture
async def user_repository(test_db):
    return UserRepository(test_db)
```

### Test Examples

#### Unit Test

```python
# tests/unit/test_services.py
import pytest
from unittest.mock import Mock, AsyncMock
from app.services.content_service import ContentService

@pytest.mark.asyncio
async def test_generate_content():
    # Arrange
    mock_ai_provider = AsyncMock()
    mock_ai_provider.generate.return_value = "Generated content"

    mock_content_repo = AsyncMock()
    mock_content_repo.save.return_value = "content_id"

    service = ContentService(
        ai_provider=mock_ai_provider,
        content_repository=mock_content_repo
    )

    # Act
    result = await service.generate_content(
        prompt="Test prompt",
        user_id="user123",
        provider="openai"
    )

    # Assert
    assert result == "Generated content"
    mock_ai_provider.generate.assert_called_once_with(
        prompt="Test prompt",
        provider="openai"
    )
    mock_content_repo.save.assert_called_once()
```

#### Integration Test

```python
# tests/integration/test_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_login_success():
    # Arrange
    login_data = {
        "email": "test@example.com",
        "password": "testpassword"
    }

    # Act
    response = client.post("/api/auth/login", json=login_data)

    # Assert
    assert response.status_code == 200
    data = response.json()
    assert "token" in data
    assert "user" in data
    assert data["user"]["email"] == login_data["email"]
```

## Code Documentation

### Docstrings

Every module, class, and function should have docstrings:

```python
"""
Module for managing AI-generated content.

This module contains services and utilities for generating,
processing, and storing content using different AI providers.
"""

class ContentService:
    """Service for managing AI-generated content.

    This service coordinates content generation through
    different AI providers and manages the storage of
    interaction history.
    """

    def __init__(self, ai_provider, content_repository):
        """Initializes the content service.

        Args:
            ai_provider: AI service provider.
            content_repository: Repository for content storage.
        """
        self.ai_provider = ai_provider
        self.content_repository = content_repository
```

### Comments

- We use comments to explain "why," not "what" or "how"
- Comments should clarify non-obvious decisions and complex logic

```python
# Good: Explains the reason for a specific approach
# We use in-memory cache instead of Redis to reduce latency
# in development environments
cache = {}

# Bad: Just describes what the code does
# Defines the cache variable as a dictionary
cache = {}
```

## Code Quality Tools

### Linting with Flake8

We use Flake8 for static code analysis:

```bash
# Configuration in .flake8
[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude = .git,__pycache__,build,dist

# Command to check
flake8 app/ tests/
```

### Type Checking with MyPy

We check static types with MyPy:

```bash
# Configuration in mypy.ini
[mypy]
python_version = 3.10
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True

# Command to check
mypy app/
```

### Testing with Pytest

We run automated tests with Pytest:

```bash
# Run all tests
pytest

# With coverage
pytest --cov=app --cov-report=html

# Specific tests
pytest tests/unit/test_services.py -v
```

## Complete Examples

### Service Example

```python
"""
Service for integration with the Notion API.

This module provides functionality to create, update, and manage
pages and databases in Notion.
"""
from typing import Dict, List, Optional
import httpx
from app.core.config import settings
from app.core.logging import logger
from app.schemas.notion import NotionPage, NotionDatabase

class NotionService:
    """Service for interacting with the Notion API."""

    def __init__(self, api_key: Optional[str] = None):
        """Initializes the Notion service.

        Args:
            api_key: Notion API key. If not provided,
                    the key configured in settings will be used.
        """
        self.api_key = api_key or settings.notion_api_key
        self.base_url = "https://api.notion.com/v1"

    async def create_page(
        self,
        parent_id: str,
        title: str,
        content: str
    ) -> Dict[str, any]:
        """Creates a new page in Notion.

        Args:
            parent_id: ID of the parent page or database.
            title: Page title.
            content: Page content in text format.

        Returns:
            Metadata of the created page.

        Raises:
            NotionAPIError: If there is an error in the API call.
        """
        try:
            # Convert content to Notion blocks
            blocks = self._text_to_blocks(content)

            # Prepare payload
            payload = {
                "parent": {"page_id": parent_id},
                "properties": {
                    "title": {
                        "title": [
                            {
                                "text": {
                                    "content": title
                                }
                            }
                        ]
                    }
                },
                "children": blocks
            }

            # Make API request
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/pages",
                    json=payload,
                    headers={
                        "Authorization": f"Bearer {self.api_key}",
                        "Notion-Version": "2022-06-28",
                        "Content-Type": "application/json"
                    }
                )
                response.raise_for_status()

                # Return created page data
                page_data = response.json()
                logger.info(f"Page created: {page_data['id']}")

                return {
                    "id": page_data["id"],
                    "url": page_data["url"]
                }

        except httpx.HTTPStatusError as e:
            logger.error(f"Notion API error: {str(e)}")
            raise NotionAPIError(f"Error creating page: {e.response.text}")
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}")
            raise NotionAPIError(f"Unexpected error: {str(e)}")

    def _text_to_blocks(self, text: str) -> List[Dict[str, any]]:
        """Converts text to Notion blocks.

        Args:
            text: Text to convert.

        Returns:
            List of blocks in Notion API format.
        """
        # Logic to convert text to Notion blocks
        # ...

class NotionAPIError(Exception):
    """Exception for Notion API errors."""
    pass
```

### Repository Example

```python
"""
Repository for managing content history.

This module provides functionality to store and retrieve
generated content history.
"""
from typing import Dict, List, Optional
import uuid
from datetime import datetime
from databases import Database
from fastapi import Depends
from app.db.database import get_database
from app.models.content import content_history

class ContentRepository:
    """Repository for content history operations."""

    def __init__(self, db: Database = Depends(get_database)):
        """Initializes the content repository.

        Args:
            db: Database connection instance.
        """
        self.db = db

    async def save(
        self,
        user_id: str,
        prompt: str,
        generated_content: str,
        provider: str,
        notion_url: Optional[str] = None
    ) -> str:
        """Saves an item to the content history.

        Args:
            user_id: ID of the user who generated the content.
            prompt: Prompt used to generate the content.
            generated_content: Content generated by the model.
            provider: AI provider used.
            notion_url: URL of the Notion page (optional).

        Returns:
            ID of the created history item.
        """
        item_id = str(uuid.uuid4())

        query = content_history.insert().values(
            id=item_id,
            user_id=user_id,
            prompt=prompt,
            generated_content=generated_content,
            provider=provider,
            notion_url=notion_url,
            created_at=datetime.now()
        )

        await self.db.execute(query)
        return item_id

    async def get_user_history(
        self,
        user_id: str,
        limit: int = 50,
        offset: int = 0
    ) -> List[Dict[str, any]]:
        """Fetches a user's content history.

        Args:
            user_id: User ID.
            limit: Maximum number of items to return.
            offset: Offset for pagination.

        Returns:
            List of history items.
        """
        query = content_history.select().where(
            content_history.c.user_id == user_id
        ).order_by(
            content_history.c.created_at.desc()
        ).limit(limit).offset(offset)

        return await self.db.fetch_all(query)
```

## Conclusion

Following these code standards helps maintain the quality and consistency of the Notion Assistant codebase. We encourage all contributors to adhere to these guidelines and suggest improvements when appropriate.

To verify your code follows the standards:

1. Run the formatters: `black app/ tests/`
2. Check linting: `flake8 app/ tests/`
3. Check types: `mypy app/`
4. Run tests: `pytest`

These tools are configured to run automatically in CI/CD, but it's recommended to run them locally before submitting a Pull Request.
